= Knative Event Router
:toc: left
:toclevels: 3
:source-highlighter: rouge
:icons: font

An event routing service designed for Knative, capable of broadcasting events to multiple clients via Server-Sent Events (SSE) and WebSockets.

== Overview

This application serves as a versatile event hub within a Knative environment. Its primary function is to act as a Knative Sink, receiving CloudEvents from a message broker. Upon receipt, it broadcasts these events in real-time to any connected WebSocket and SSE clients.

It also provides endpoints for clients to send messages back into the system. WebSocket clients can send arbitrary messages, and a dedicated log sink endpoint can accept structured logs. Both are converted into new CloudEvents and forwarded to a configurable Knative Broker (`K_SINK`), enabling a full-duplex event-driven architecture.

=== Features

* **Knative Sink Integration**: Receives CloudEvents via a standard `POST` request to the root path (`/`).
* **Real-time Broadcasting**: Pushes incoming events to clients using:
    ** **Server-Sent Events (SSE)** on the `/events` endpoint.
    ** **WebSockets** on the `/ws` endpoint.
* **Event Sourcing**: Ingests events from clients and external systems:
    ** Receives messages from WebSocket clients and forwards them as CloudEvents.
    ** Provides a `/eventsink` endpoint to convert structured JSON logs into CloudEvents.
* **Concurrent & Scalable**: Utilizes goroutines and channels for non-blocking, concurrent handling of multiple clients.
* **Graceful Shutdown**: Handles `SIGINT` and `SIGTERM` signals for a clean shutdown process, ensuring connections are terminated properly.

---

== Configuration

The application is configured using environment variables.

|===
| Variable | Description | Default

| `PORT`
| The port on which the HTTP server will listen.
| `8080`

| `K_SINK`
| *Required*. The URL of the Knative sink (e.g., a Broker URL) where new events generated by this service will be sent. The application will not start without this variable.
| `(none)`

| `DEFAULT_EVENT_SOURCE`
| The value used for the `source` attribute in CloudEvents created by this service.
| `urn:k8s:knative-logevent-router`
|===

---

== Deployment (Knative)

This application is designed to be deployed as a Knative Service.

=== 1. Build and Push the Docker Image

First, create a `Dockerfile` for the Go application.

[source,dockerfile]
----
# Use the official Golang image to create a build artifact.
FROM golang:1.22-alpine as builder

WORKDIR /app

# Copy go mod and sum files
COPY go.mod go.sum ./
# Download all dependencies. Dependencies will be cached if the go.mod and go.sum files are not changed
RUN go mod download

# Copy the source code
COPY . .

# Build the Go app
RUN CGO_ENABLED=0 GOOS=linux go build -v -o /server .

# Use a minimal image for the final container
FROM alpine:latest

# Copy the binary from the builder stage
COPY --from=builder /server /server

# Set required env variables (can be overridden in Knative service.yaml)
ENV PORT=8080
ENV GIN_MODE=release

# Expose port
EXPOSE 8080

# Command to run the executable
CMD ["/server"]
----

Build and push the image to a container registry accessible by your Kubernetes cluster.

[source,bash]
----
# Replace with your registry and image name
export IMAGE="872855011810.dkr.ecr.us-west-2.amazonaws.com/logevent:v0.1.1"

docker build -t $IMAGE .
docker push $IMAGE
----

=== 2. Deploy as a Knative Service

Create a Knative service definition file (`service.yaml`). This example assumes you have a Knative Broker named `default` in the same namespace. The service will send events generated from WebSocket clients and the log sink to this broker.

[source,yaml]
----
apiVersion: serving.knative.dev/v1
kind: Service
metadata:
  name: event-router
spec:
  template:
    spec:
      containers:
        - image: your-registry/knative-event-router:v1 # <-- IMPORTANT: Replace with your image
          ports:
            - containerPort: 8080
          env:
            - name: PORT
              value: "8080"
            - name: K_SINK
              # This sends events originating from this service (e.g., from a WebSocket client)
              # to the default broker in the current namespace.
              value: "http://broker-ingress.knative-eventing.svc.cluster.local/default/default"
            - name: DEFAULT_EVENT_SOURCE
              value: "urn:dev:event-router"
          livenessProbe:
            httpGet:
              path: /healthz
          readinessProbe:
            httpGet:
              path: /readyz
---
# (Optional) A Knative Trigger to send events from the Broker to the router.
# This creates a feedback loop for demonstration purposes.
apiVersion: eventing.knative.dev/v1
kind: Trigger
metadata:
  name: event-router-trigger
spec:
  broker: default
  subscriber:
    ref:
      apiVersion: serving.knative.dev/v1
      kind: Service
      name: event-router
----

Apply the configuration to your cluster:

[source,bash]
----
kubectl apply -f service.yaml
----

---

== API Endpoints & Usage Examples

Let's assume the Knative service is available at `http://event-router.default.127.0.0.1.sslip.io`.

=== 1. Subscribing to Events (SSE)

Clients can receive a real-time stream of CloudEvents by connecting to the `/events` endpoint.

==== cURL

[source,bash]
----
# Keep-alive connection to the SSE endpoint to receive events
curl -N -H "Accept:text/event-stream" http://event-router.default.127.0.0.1.sslip.io/events
----

==== Go Client

This example client connects to the SSE stream and prints incoming events.

[source,go]
----
package main

import (
	"bufio"
	"fmt"
	"log"
	"net/http"
	"strings"
)

func main() {
	url := "http://event-router.default.127.0.0.1.sslip.io/events"
	resp, err := http.Get(url)
	if err != nil {
		log.Fatalf("Failed to connect to SSE endpoint: %v", err)
	}
	defer resp.Body.Close()

	fmt.Println("Connected to SSE stream. Waiting for events...")
	scanner := bufio.NewScanner(resp.Body)
	for scanner.Scan() {
		line := scanner.Text()
		if strings.HasPrefix(line, "data:") {
			fmt.Println(line)
		}
	}

	if err := scanner.Err(); err != nil {
		log.Fatalf("Error reading from stream: %v", err)
	}
}
----

=== 2. Connecting via WebSocket

A bidirectional connection can be established at `/ws`. Clients can receive all broadcasted events and can also send messages, which will be converted to CloudEvents and sent to the `K_SINK`.

==== websocat (`stc` equivalent)

NOTE: `stc` is not a standard command-line tool. The following example uses `websocat`, which is a versatile command-line client for WebSockets, often considered the `curl` for WebSockets.

[source,bash]
----
# Install websocat: https://github.com/vi/websocat
# Connect to the WebSocket endpoint
websocat ws://event-router.default.127.0.0.1.sslip.io/ws

# Once connected, you can type messages and press Enter.
# These messages will be sent to the server.
# Any events the server broadcasts will be printed to your terminal.
----

==== Go Client

[source,go]
----
package main

import (
    "log"
    "net/url"
    "time"
    "github.com/gorilla/websocket"
)

func main() {
    u := url.URL{Scheme: "ws", Host: "event-router.default.127.0.0.1.sslip.io", Path: "/ws"}
    log.Printf("Connecting to %s", u.String())

    c, _, err := websocket.DefaultDialer.Dial(u.String(), nil)
    if err != nil {
        log.Fatal("dial:", err)
    }
    defer c.Close()

    done := make(chan struct{})

    // Reader goroutine
    go func() {
        defer close(done)
        for {
            _, message, err := c.ReadMessage()
            if err != nil {
                log.Println("read:", err)
                return
            }
            log.Printf("Received: %s", message)
        }
    }()
    
    // Writer goroutine
    ticker := time.NewTicker(5 * time.Second)
    defer ticker.Stop()

    for {
        select {
        case <-done:
            return
        case t := <-ticker.C:
            msg := "Hello from Go Client at " + t.String()
            err := c.WriteMessage(websocket.TextMessage, []byte(msg))
            if err != nil {
                log.Println("write:", err)
                return
            }
            log.Printf("Sent: %s", msg)
        }
    }
}
----

=== 3. Sending an Event to the Router

To make the router broadcast something, send a valid CloudEvent to its root endpoint (`/`). This is how it receives events from a Knative Broker.

==== cURL

This sends a CloudEvent using the HTTP structured format.

[source,bash]
----
curl -X POST http://event-router.default.127.0.0.1.sslip.io/ \
-H "Content-Type: application/cloudevents+json" \
-d '{
    "specversion": "1.0",
    "type": "com.example.curl.sent",
    "source": "urn:dev:curl-command",
    "id": "a89b-4c54-801a-ce923b7e7111",
    "time": "2025-06-10T12:00:00Z",
    "datacontenttype": "application/json",
    "data": {
        "message": "Hello from cURL!",
        "value": 42
    }
}'
----

==== Postman

1.  **New Request**: Create a new `POST` request.
2.  **URL**: Set the URL to `http://event-router.default.127.0.0.1.sslip.io/`.
3.  **Headers**:
    * Add a header with the key `Content-Type` and the value `application/cloudevents+json`.
4.  **Body**:
    * Select the `raw` radio button and choose `JSON` from the dropdown.
    * Paste the same JSON payload from the cURL example above.
5.  **Send**: Click "Send". You should receive a `200 OK` response. All connected SSE and WebSocket clients will receive this event.

=== 4. Sending Data to the Log Sink

The `/eventsink` endpoint accepts arbitrary JSON and converts it to a CloudEvent.

==== cURL

[source,bash]
----
curl -X POST http://event-router.default.127.0.0.1.sslip.io/eventsink \
-H "Content-Type: application/json" \
-d '{
    "level": "info",
    "message": "User logged in successfully",
    "module": "com/example/auth/service",
    "data": {
        "userId": "user-123",
        "ipAddress": "192.168.1.100"
    }
}'
----

The service will receive this, create a CloudEvent with `type: com.example.auth.service`, and send it to the `K_SINK`. If you have a trigger set up as shown in the deployment section, this event will then be sent back to the router and broadcast to all clients.